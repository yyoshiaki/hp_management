Title:Pythonの変数と代入について
Date: 2019.04.14
Tags: python
Slug: python_value
Author:小川
Summary:

Pythonの変数、ふだん何気なく使っていますが、やっていることは実は結構複雑です。主にC/C++と対比しつつ簡単にまとめてみます。

実際のところ、よく知らなくてもあまり影響がない場合が殆どです。が、複雑な操作を行ったり何か変数の挙動が不審な場合などは、思い出してみるのもよさそうです。

## 変数は参照である

一言でいえば表題の通り。
Pythonでの**変数への代入とは、変数の参照するメモリ（インスタンス）を切り替えること**であり、**メモリの内容を書き換えることではない**。これが多くの言語（C/C++など）と大きく違うところです。

## 変数の代入(1)
例えばこんなコード。

```python
# Python3
a = 0
a = 1
print(a)  # 1を出力
```
C++で書き換えると、

```cpp
// C++
int a = 0;
a = 1;
cout << a << endl;  // 1を出力
```
なのか？？
（#include\とかint main(void){...}とかは全部省略。）  

**実は違う**のです。  
C++の方では`a`で表されるメモリ領域を一つ確保し、そこにまず`0`をセット、次に`1`を、**同じメモリ領域を書き換えて**セットしています。  

Pythonの方はそうではありません。まず`0`の値を持つメモリ領域を確保し、**変数`a`がそこを指すように**します。次に`1`の値を持つ**別のメモリ領域を確保**し、変数`a`がそこを指すように切り替えます。

C++で無理矢理それっぽいものを書くと、

```cpp
// C++
int *a = new int(0);
a = new int(1);
cout << *a << endl;  // 1を出力
```
のようになります。  
（C++に参照定数はあるが参照変数がないため、ポインタで書いた。）

実はこのC++コード、2行目で確保した`int(0)`メモリを3行目の`int(1)`代入時に**放棄**していて、**メモリリーク**が起こっています。C++では、これを処理（メモリ解放）するためのコードを本当は書き加えないといけません。  
しかし、Pythonではそれを**ガベージコレクタ**という仕組みが**勝手に代行**してくれます。逆にこれがないと、Pythonではメモリリークが頻繁に起こって大変なことになります。

## 変数の代入(2)
問題です。次のコードは何を出力するでしょうか。

```python
# Python3
a = 0
b = a
a = 1
print(b)  # 何が出る？
```

**答えは「`0`」**です。  
C++で書いた似たようなコード、

```cpp
// C++
int a = 0;
int b = a;
a = 1;
cout << b << endl;  // 出力は「0」
```
も結果は同じなのですが、内部動作は全く異なります。**Pythonでの変数代入は参照の切り替え**であることがやはりポイントです。

一方で、過程は違えどPythonもC++も結果は変わりません。**気にしなくても大抵はうまくいく**、というのも大事なところです(笑)。

## 関数引数はすべて参照渡し
「変数が全て参照」であることから、関数引数もまた**参照渡し**となります。C/C++のデフォルトである**値渡し**と異なり、メモリのコピーなどは行われません。

では再び問題。次のコードは何を出力するでしょう？

```python
# Python3
def func(x):
	x = 1

a = 0
func(a)
print(a)
# ここまで。このprint()は何を出力するか？0？1？
```

「参照渡し」を知っている人ほど、「1」と答えたくなりそうですが、、  

**答えは「0」**です。何故か？  
`func(a)`を呼び出した時点では、**`a`と`x`の指すメモリは同じ`0`**ですが、`x = 1`で`x`の指すメモリは**別に確保された`1`**に切り替わります。**`a`および、`a`の指す`0`には何の変化も無い**のです。このあたりは前項の問題とほとんど同じです。

## 「変数への代入」ではない場合
例えばこんなとき。

```python
# Python3
a = [0, 1]
b = a
a[0] = 2
print(b)  # 出力は[2,1]
```
3行目で`b`と`a`は同じリストを参照するようになります。4行目では、そのリスト（これも参照の列みたいなもの）の最初の成分を、`0`でなく`2`のメモリを参照するように切り替えます。全体として見れば`a`と`b`が同じリストを参照していることに変わりはないので、この変更は`b`にも反映されています。

これは、前項の関数引数で若干の問題を引き起こします。  
次のコード、前項で見たものにそっくりですが、、、

```python
# Python3
def func2(x):
	x[0] = 1

a = [0]
func2(a)
print(a[0])
```
**前項とは違い、この出力は「`1`」**です。  
関数が呼び出されると**`a`と`x`の指すリストは一貫して同じ**で、その一部が書き換えられるからです。これは**リストでなくnumpy配列の場合もほぼ同じ**です。


## まとめ
以上見てきたように、Pythonの変数は全て参照、関数引数は全て参照渡しです。これらが組み合わさると、結果的に全てを値渡しにした場合（C/C++）と殆ど違いが見えなくなり、あまり意識することなくプログラムを書けるようになっています。

しかし、リストや配列（や、もっと複雑なクラスオブジェクトなど）のように部分的に書き換え可能なものを扱う場合などには、この違いはかなり重要になってきます。怪しいと思ったら、各変数が何を参照しているか、互いに同じか違うかなどを、その都度考えてみてください。

ひとまず今回はここまで。おしまい。
※画像は[公式](https://www.python.org/)のものです。
